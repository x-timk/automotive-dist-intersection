\documentclass{memoir}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,italian]{babel}
\usepackage{tikz}
\usetikzlibrary{automata,positioning,topaths}

\title{Implementazione di un sistema di incrocio stradale intelligente \\ for the Project of Distributed Systems}

\author{Tiziano Mele\\Valentino Picotti\\DMIF, University of Udine, Italy}

\date{Version 1, \today}

\begin{document}


%\begin{titlingpage}
\maketitle
\begin{abstract}
  Un sistema di incrocio stradale intelligente vuole essere una soluzione al
  problema della congestione stradale. Con l'avvento dei sistemi wireless e
  autonomici ci si chiede se sia possibile per i veicoli stradali poter decidere
  direttamente tra di loro chi debba impegnare l'incrocio. Di seguito si indaga
  una soluzione che permatta di eliminare le lanterne semaforiche in modo da
  ridurre i tempi medi di attesa dei veicoli in coda.
\end{abstract}
%\end{titlingpage}

\chapter{Introduzione}\label{ch:intro}

La soluzione che viene proposta in questo lavoro vuole essere di tipo
distribuito, dove i singoli veicoli sono entità indipendenti e con conoscenza
parziale dell'ambiente circostante data dalla sensoristica di bordo. Compito dei
veicoli è quello di formare una rete peer-to-peer che permetta loro di
comunicare autonomamente, senza bisogno di un server centrale.

% TODO: Da riconsiderare per capitolo 3.1
% Inoltre la soluzione mira ad essere fisicamente plausibile, ipotizzando un
% deploy in una situazione reale (o mondo reale)
% soluzione fisicamente plausibile
% al funzionamento fisico della sensoristica
% Molte scelte sono state effettuate pensando al livello tecnologico della
% sensoristica ad oggi disponibile; ad esempio è stato tenuto conto del fatto che
% i dispositivi wireless hanno un raggio di azione limitato.

I principali requisiti che si vogliono soddisfare sono:
\begin{description}
\item[Sicurezza stradale] Le auto che attraversano l'incrocio non devono
  scontrarsi.
\item[Liveness] Ogni macchina che si trova ad un incrocio deve prima o poi
  attraversarlo.
\item[Fairness] Quando un'auto chiede di impegnare l'incrocio, esiste un tempo
  limite entro cui le viene assegnato.
\item[Deadlock freedom] Non possono verificarsi situazioni in cui nessuna
  macchina nell'incrocio può muoversi.
\item [Fault Tolerant] Il sistema deve funzionare in caso di guasti fisici o
  logici. Un guasto fisico comporta che la macchina è attiva nella rete ma non
  può muoversi. Un guasto logico comporta che la macchina non è più
  raggiungibile nella rete, ma comunque presente fisicamente nell'ambiente.
\item [Distribuito] Le macchine si parlano tra di loro senza un server centrale
  che potrebbe diventare un SPOF.
\item [Generale] E' possibile utilizzare il sistema su un qualsiasi tipo di
  incrocio: è sufficiente cambiare il grafo di descrizione dell'incrocio (non è
  necessario agire modificando la struttura del sistema e degli algoritmi).
\end{description}

\subsection{Struttura complessiva dell'implementazione}

Lo spazio fisico è partizionato in una griglia dove ogni macchina può occupare
al più una cella. La griglia è poi rappresentata da un grafo orientato e pesato
in cui i nodi rappresentano le singole celle della griglia. Si ha una collisione
quando due auto vanno ad occupare la stessa cella nella griglia (lo stesso nodo
del grafo). Le macchine sono dotate di sensori di prossimità, gps, e un modulo
wifi per comunicare con le altre macchine. Una macchina può avanzare solo se il
sensore di prossimità non rileva ostacoli e mediante il modulo gps la macchina è
in grado di capire se si trova in prossimità di un incrocio. In quest'ultimo
caso prima di avanzare deve coordinarsi con eventuali altre macchine presenti.
Il coordinamento si traduce in una fase di elezione di un leader dell'incrocio,
che poi deciderà quali macchine far passare.


Per testare il sistema è stato implementato un ambiente simulato le cui
funzionalità rispecchino il più possibile quelle di un ambiente reale.

\chapter{Analisi}\label{ch:analysis}
In questo capitolo si descrivono requisi funzionali e non funzionali della
soluzione fornita.

\section{Requisiti funzionali}

Al fine di poter fornire una simulazione realistica sono stati individuati i
seguenti requisiti funzionali per gli attori che vi partecipano.

\subsection{Veicolo}

Un veicolo deve soddisfate i seguenti requisiti funzionali:
\begin{itemize}
\item Muoversi in autonomia
\item Poter interrogare i sensori di prossimità
\item Conoscere la sua posione gps attuale e più in generale conoscere il suo
  intero tragitto
\item Riconoscere se si trova in prossimatà di un incrocio, al suo interno o se
  sta percorrendo un tratto senza incroci
\item Riconoscere eventuali macchine guaste che ostacolino il suo percorso
\item Richiedere l'intervento del carro attrezzi per i veicoli che si suppone
  essere guasti
\item Disporre di un meccanismi di comunicazione broadcast per poter comunicare
  con le auto nelle vicinanze
\item Disporre di un meccasnismo di comunicazione unicast che permetta di
  comunicare con una singola auto
\item Essere in grado di coordinarsi con gli altri veicoli per attraversare
  l'incrocio
\end{itemize}

\subsection{Ambiente}

L'ambiete è l'unico attore che dispone della conoscenza globale dell'incrocio,
compresa la posizione esatta di ogni auto. Deve quindi soddisfare i seguenti
requisiti:
\begin{itemize}
\item Conoscere la posizione esatta di ogni veicoli
\item Rispondere alle richieste dei sensori di prossimità dei veicoli
\item Simulare la comunicazione broadcast inoltrando il messaggio ai soli
  veicoli a portata wireless del mittente
\item Simulare l'intervento del carro attrezzi a seguito di una richiesta di
  intervento da parte di un veicolo
\end{itemize}

La struttara dell'incrocio oltre che fornire una descrizione topologica e
spaziale deve anche indicare le traittorie di percorrenza ammesse. Tale
struttura la si considera come dato di input della simulazione.

\subsection{Interfaccia grafica}

La soluzine prevede la presenza di un interfaccia grafica dalla quale è
possibile visualizzare ad ongi istante lo stato dell'incrocio per monitorarne il
funzionamento e aggiungere nuovi veicoli alla simulazione.


\section{Requisiti non funzionali}
I requisiti non funzionali che una soluzion deve soddisfare sono:
\begin{description}
\item[Sicurezza stradale] Le auto che attraversano l'incrocio non devono
  scontrarsi.
\item[Liveness] Ogni macchina che si trova ad un incrocio deve prima o poi
  attraversarlo.
\item[Fairness] Quando un'auto chiede di impegnare l'incrocio, esiste un tempo
  limite entro cui le viene assegnato.
\item[Deadlock freedom] Non possono verificarsi situazioni in cui nessuna
  macchina nell'incrocio può muoversi.
\item[Near real-time] È necessario imporre un limite di tempo all'esecuzione
  della fase di coordinamento, che deve avvenire in \emph{near real-time} per
  scongiurare fermate prolungate ai veicoli.
\end{description}

Inoltre la soluzione soddisfa le seguenti trasparenza:
\begin{description}
\item[Access transparency] Non c'è un concetto di risorsa remota a cui le
  macchine accedono. Le macchine utilizzano dati ricavati da sensori oppure
  messaggi ricevuti da altre macchine.
\item[Location transparency] Una macchina comunica con i vicini senza conoscerne
  la loro posizione fisica nell'ambiente.
\item[Concurrency transparency] Più macchine possono impegnare l'incrocio senza
  interferire l'una con l'altra.
\item[Failure transparency] Sono ammessi fallimenti fisici e logici delle
  macchine in un qualsiasi momento. Se la macchina si guasta fisicamente è lei
  stessa a ``chiamare il carro attrezzi''; se la macchina si guasta logicamente,
  è la macchina dietro che, passato un certo intervallo di tempo, chiede
  l'intervento di un carro attrezzi. Dovesse guastarsi il leader dell'incrocio,
  si procede con l'elezione di un nuovo leader.
\item[Mobility transparency] Il coordinamento funziona a prescindere dalla
  posizione del leader, che può essere uno qualsiasi fra i veicoli presenti.
\end{description}

Everything about mode and transparencies: availability, mobility, security, fault tolerance, etc.

Are there execution time bounds? Minimum data rates?

If requested, specific platforms/languages/middlewares requirements for the implementation can be decided here. (E.g.: if the project is on a SOA, we may request that functions are offered via SOAP or RESTful services). 




\newpage

Come primo passaggio viene creato un processo "environment" dove viene salvato
lo stato globale dell'incrocio. L'incrocio viene tradotto in un grafo orientato
pesato, dove ogni nodo conterrà le seguenti informazioni:
\begin{itemize}
\item Nome
\item Tipologia di nodo: TailNode(Nodo in coda) TopNode (Nodo in prossimità di
  un incrocio) CrossNode(Nodo incrocio)
\item Elenco di macchine che occupano il nodo stesso
\end{itemize}
Il peso degli archi del grafo viene assegnato in base alla distanza fisica tra i
due nodi.
Questo modulo viene interrogato dalle varie macchine per simulare dati relativi
alla sensoristica.

Ogni veicolo sarà implementato come un processo che quindi potrà interrogare i
sensori per ottenere le informazioni su posizione, ostacoli, percorso più breve
verso la sua destinazione.

Le macchine sono in relazione client-server con l'environment. Ogni automobile è
una macchina a stati finiti per la quale si prevede di utilizzare il behaviour
di erlang gen\_statem. Gli stati principali per un veicolo sono:
\begin{itemize}
\item \texttt{INQUEQUE}: La macchina si trova in questo stato quando è in coda
  (non è la prima macchina della fila)
\item \texttt{DISCOVER}: La macchina è la prima della file. In questo stato la
  macchina manda un broadcast per scoprire le auto vicine.
\item \texttt{ELECTION}: La macchina è la prima della fila. E' in corso
  l'elezione di un leader dell'incrocio
\item \texttt{SLAVE}: L'elezione si è conclusa e la macchina non è leader. Mando
  il mio percorso al leader e attendo risposta "verde"/"rosso".
\item \texttt{M-FETCH}: La macchina è stata eletta leader dell'incrocio. Attendo
  i percorsi delle macchine SLAVE.
\item \texttt{M-COORD}: In base ai percorsi e alle priorità delle macchine mando
  messaggi "verde"/"rosso" agli SLAVE.
\item \texttt{CROSSING}: La macchina è in questo stato se si trova su un nodo
  del grafo di tipo CrossNode.
\item \texttt{PH-FAULT}: La macchina ha un guasto fisico.
\end{itemize}

Ogni veicolo può ricevere uno dei seguenti eventi:
\begin{itemize}
\item \texttt{disc}: La macchina è appena arrivata in prossimità dell'incrocio e
  manda in broadcast un "discover" con il suo pid e il suo percorso. A livello
  pratico per simulare il broadcast il messaggio di discover viene mandato
  all'environment che poi rigira alle altre macchine. Queste quindi a loro volta
  mandano un messaggio di "hellofrom" alla nuova macchina (con il loro
  percorso).
\item \texttt{disc\_tm}: lo stato \texttt{DISCOVER} ha un suo timeout. Una volta
  trascorso viene innescato questo evento.
\item \texttt{wait(tag:*)}: se la macchina si trova in stato \texttt{DISCOVER} e
  riceve questo evento rimane nello stato \texttt{DISCOVER} e resetta il
  timeout.
\item \texttt{hello(pid)}: se la macchina si trova in stato \texttt{DISCOVER},
  mi salvo il pid ricevuto tra i conosciuti.
\item \texttt{elect}: Messaggio di \emph{election} dell'algoritmo bully.
\item \texttt{coord}: Messaggio di \emph{coordinator} dell'algoritmo bully.
\item \texttt{ans}: Messaggio di \emph{answer} dell'algoritmo bully.
\item \texttt{elect\_tm}: Evento di timeout (elezione fallita) dell'algoritmo bully.
\item \texttt{route}: messaggio contenente id, priorità, lista macchine con cui
  è in conflitto.
\item \texttt{route\_tm}: evento di timeout per lo stato \texttt{M-FETCH}.
\item \texttt{green}: Messaggio che notifica a macchina in stato \texttt{SLAVE}
  che può attraversare incrocio.
\item \texttt{red}: Messaggio che notifica a macchina in stato \texttt{SLAVE}
  che non può attraversare incrocio.
\item \texttt{gr\_timeout}: evento di timeout per lo stato \texttt{SLAVE} e
  \texttt{M-COORD}.
\end{itemize}

\begin{tikzpicture}[shorten >=1pt,
  node distance=2.5cm,on grid,auto,
  bend angle=30, font=\scriptsize\ttfamily, scale=0.3]
  \node[state,initial,accepting] (queue)                 {INQUEUE};
  \node[state,accepting] (disc) [right=of queue] {DISCOVER};
  \node[state,accepting] (elec) [right=of disc,xshift=0.5cm]  {ELECTION};
  \node[state,accepting] (slave) [xshift=1cm,above right=of elec]  {SLAVE};
  \node[state,accepting] (m-fetch) [xshift=1cm,below right=of elec]  {M-FETCH};
  \node[state,accepting] (m-coord) [right=of m-fetch,xshift=0.5cm]  {M-COORD};
  \node[state,accepting] (cross) [above right=of m-coord]  {CROSSING};
  \node[state,accepting,initial,initial text=fault] (fault) [below=of disc]  {PH-FAULT};
  % \node[state,accepting]         (q_1) [right=of q_0] {$q_1$};
  % \node[state,accepting]         (q_2) [right=of q_1] {$q_2$};
  \path[->] (queue)   edge node {on\_top} (disc)
            (disc)    edge [loop above] node [xshift=-0.5cm] {disc,hello,wait} ()
                      edge node {disc\_tm} (elec)
                        edge [bend right] node[yshift=-0.1cm] {elec} (elec)
                        edge [bend left] node[yshift=0.1cm,xshift=0.7cm] {coord} (slave)
              (elec)    edge [loop below] node {disc,elect,ans} ()
                        edge node {coord} (slave)
                        edge [bend right] node[yshift=0.45cm] {elec\_tm} (disc)
                        edge node[xshift=-0.4cm,yshift=0.2cm] {master} (m-fetch)
              (slave)   edge [loop above] node {disc} ()
                        edge node {green} (cross)
                        edge [bend right=50] node[xshift=-0.5cm,yshift=0.7cm] {red,gr\_tm} (disc)
              (m-fetch) edge [loop above] node {route,disc} ()
                        edge node {route\_tm} (m-coord)
              (m-coord) edge [loop above] node {disc,route} ()
                        edge [below] node [xshift=0.5cm] {green} (cross)
                        edge [bend left=50] node {red,gr\_tm} (disc)
              (cross)   edge [loop above] node {disc} ();
\end{tikzpicture}

Ogni veicolo ha un suo valore di priorità iniziale, che viene incrementato ogni
volta che il veicolo riceve il messaggio \texttt{red} (lo può ricevere solo se è
in stato \texttt{SLAVE} o \texttt{M-COORD}). Il leader dell'incrocio decide chi
far passare nel seguente modo:
\begin{itemize}
\item Ordina le macchine per priorità;
\item Farà sicuramente passare la prima.
\item Calcola un insieme massimale di macchine indipendenti rispetto alla prima
\end{itemize}

In this chapter, we describe in detail functional and non-functional
requirements of a solution for the problem. Ogni macchina ha un suo "semaforo"
interno: quando si trova in prossimità di un incrocio può passare solo se il suo
semaforo è verde

\section{Functional requirements}
Which functions must be offered to users / other programs?  Which are the input data and the output data? Which is the expected effect? 

\section{Non functional requirements}
Everything about mode and transparencies: availability, mobility, security, fault tolerance, etc.

Are there execution time bounds? Minimum data rates?

If requested, specific platforms/languages/middlewares requirements for the implementation can be decided here. (E.g.: if the project is on a SOA, we may request that functions are offered via SOAP or RESTful services). 



\chapter{Project}

This chapter is devoted to the description of the general architectures, and specific algorithms.

\section{Logical architecture}
Describe the components of your systems: modules/objects/components/services.
For each component, describe the functionalities it implements, and by who is used.

\section{Protocols and algorithms}
Communication between components.  UML sequence diagrams go here.

Also, put here a detailed description of distributed algorithms used to solve specific problems of the project.

\section{Physical architecture and deployment}
Which nodes and platforms involved, and where each component is deployed.

\section{Development plan}
Since it is difficult to predict just how hard implementing a new system will be, you should formulate as a set of ``tiers,'' where the basic tier is something you?re sure you can complete, and the additional tiers add more features, at both the application and the system level.

\chapter{Implementation}

Details about the implementation: every choice about platforms, languages, software/hardware, middlewares, which has not been decided in the requirements.


Important choices about implementation should be described here; e.g., peculiar data structures.


\chapter{Validation}

Check if requirements from Chapter~\ref{ch:analysis} have been fulfilled.
Quantitative tests (simulations) and screenshots of the interfaces are put here.


\chapter{Conclusions}

What has been done with respect to what has been promised in Chapters~\ref{ch:intro} and \ref{ch:analysis}, and what is left out.

\appendix

\chapter{Appendix}

In the Appendix you can put code snippets, snapshots, installation instructions, etc.


\chapter*{Evaluation}
Your system will be judged mainly on how it operates as a distributed system. The primary evaluation will be according to whether your system has the following attributes:
\begin{itemize}
\item  It should be an interesting distributed system, making use of some of the algorithms we have covered in class for distributed synchronization, replication, fault tolerance and recovery, security, etc.
\item The software should be well designed and well implemented, in terms of the overall architecture and the detailed realization.
\item You should devise and apply systematic testing procedures, at both the unit and systems levels.
\item The system should operate reliably and with good performance, even in the face of failures.
\end{itemize}
Important, but secondary considerations include:
\begin{itemize}
\item Time taken to do the project (the sooner the better, but do not miss details in order to end sooner)
\item  How nice is the application's appearance: does it have a nice interface or a compelling visual display?
\end{itemize}

\end{document}


% Local Variables:
% ispell-dictionary: "italiano"
% End:
